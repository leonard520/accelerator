accelerator:
  displayName: Azure Accelerator
  description: Demo
  iconUrl: https://raw.githubusercontent.com/leonard520/accelerator/main/asc.png
  tags:
  - Azure
  options:
  
  - name: projectName
    label: projectName
    description: The project name.
    defaultValue: hello-world
    required: true
    display: true

  - name: projectType
    inputType: select
    choices:
      maven: Maven
      gradle: Gradle
    defaultValue: maven
    display: true

engine:
  # this is the 'global' transformation node. It produces the final set of
  # files to be zipped and returned from the accelerator.
  # As input it receives all the files from the accelerator repo root.

  # The properties in this node dictate how this set of files is
  # transformed into a final set of files to zip up as the accelerator
  # result.

  include:
    ["**/*.md", "**/*.xml", "**/*.gradle", "**/*.java"]
    # This globally defined `include` filters the set of files
    # retaining only those matching a given list of path patterns.
    # This can ensure that only files in the repo matching the list of
  # patterns will be seen / considered by the accelerator.

  exclude:
    ["**/secret/**"]
    # This globally defined `exclude` further restricts what files are considered.
  # This example ensures files in any directory called `secret` are never considered.

  # Under 'let' you can define additional variables and assign them values
  # These 'derived symbols' function much like options, but instead of
  # being supplied from a UI widget, they are computed by the accelerator itself.
  let:
    - name: includePoms # name of a symbol, must be camelCase
      expression:
        "#buildType == 'Maven'" # <- SpEL expression given as a string. You must take care to use
      # proper quotes to avoid yaml treating '#' as starting a comment.
    - name: includeGradle
      expression: "#buildType == 'Gradle'"
  merge: # This merge section executes each of its children 'in parallel'.
    # Each child receives a copy of the current set of input files.
    # (i.e. the files that are remaining after considering the `include` and `exclude`.
    # Each of the children thus produces a set of files.
    # Merge then combines all the files from all the children, as if by overlaying
    # them on top of eachother in the same directory.
    # If more than one child produces a file with the same path,
    # this 'conflict' is resolved by dropping the file contents from the earlier child
    # and keeping only the later one.
    # merge child 1: this child node wants to contribute 'gradle' files to the final result
    - condition:
        "#includeGradle" # this child is disabled if the Gradle option was not selected by the user
      # A disabled child doesn't contribute anything to the final result.
      include: ["*.gradle"] # this child only focusses on gradle files (ignoring all other files)
    # merge child 2: this child wants to contribute 'pom' files to the final result
    - condition: "#includePoms"
      include: ["pom.xml"]
    # merge child 3: this child wants to contribute Java code and README.md to the final result
    - include: ["**/*.java", "README.md"]
      # Using: chain you can specify additional transformations to be applied to the set
      # of files produced by this child (i.e. the `ReplaceText` below is only applied to .java
      # files and README.md)
      chain:
        - type: ReplaceText
          substitutions:
            - text: "Hello World!"
              with: "#greeting"
  chain:
    # Globally specified chain, works just like the one `from merge child 3`. But because it is # global, it applies transformation to all files globally.
    #
    # The chain has a list of child transformations. These transformation are applied after
    # everything else in the same node (here we are in the 'global node').
    #
    # The children in a chain are applied sequentially.
    - type: RewritePath
      regex: (.*)simpleboot(.*)
      rewriteTo: "#g1 + #packageName + #g2" # SpEL expression. You can use '#g1' and '#g2' to reference 'match groups'
    - type: ReplaceText
      substitutions:
        - text: simpleboot
          with: "#packageName"
  onConflict:
    Fail # other values are 'UseFirst', 'UseLast' or 'Append'
    # when merging (or really any operation) produces multiple files at the same path
    # this defines how that conflict is handled.
    # Fail: raise an error when conflict happens
    # UseFirst: keep the contents of the first file
    # UseLast: keep the contents of the last file
  # Append: keep both as by using `cat <first-file> <second-file>`).